package chapter12;

public class chapter12 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		 * 프로세스와 스레드
		 *운영체제에서는 실행 중인 하나의 에플리케이션을 프로세스라고 부른다.
		 * 스레드는 한가지 작업을 실행하기 위해 순차적으로 실행할 코드를 이어 놓은 것이다.
		 * 
		 * 보통 익명객체 사용하는 것을 많이 이용함
		 * Thread thread=new Thread(){
		 * @Override
		 * public void run(){
		 * Toolkit ~~~~~~
		 * 
		 */
		
		
		//스레드의 이름
		
		/* thread.setName("스레드 이름"); 스레드 이름 설
		 * thread.getName();
		 * Thread thread=Thread.currentThread() 실행하는 현재 스레드의 참
		 */
		
		//스레드 우선순위
		
		/* 자바의 스레드 스케줄링은 우선순위 방식과 순환 할당 방식을 사용한다
		 * 우선순위 방식은 우선순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케쥴링 하는것이고
		 * 순환 할당 방식은 시간 할당량을 정해서 하나의 스레드를 정해진 시간만큼 실행하고 다시 다른
		 * 스레드를 실행하는 방식을 말한다
		 */
		
		/*
		 *thread.setPriority(우선순위);
		 */
		
		//공유 객체를 사용할때의 주의할 점
		
		/*
		 *멀티 스레드 프로그램에서 A B 스레드를 사용할때 A B 모두 한가지의 객체를 공유하는 스레드라면
		 *A가 값을 변경할때 B의 스레드도 값을 변경하기 때문에 A는 엉터리 값을 이용할 수 있다.
		 *이럴 때 스레드를 정지시키는 Thread.sleep 을 이용하자
		 *아니면 synchronized 를 이용할수있다 ex
		 *public synchronized void method(){}
		 */
		
		//스레드 상태
		
		/*
		 * 스레드 객체를 생성하고 start() 메소드를 호출하면 곧바로 스레드가 실행되는 것 처럼 보이지만
		 * 사실은 실행 대기 상태가 된다. 실행 대기상태에 있는 스레드 중에서 스레드 스케쥴링으로 선택된
		 * 스레드가 비로서 CPU를 점유하고 run() 메소드를 실행한다.
		 * run() 메소드를 다 실행하기 전에 스케줄링에 의해 다시 실행 대기 상태로 돌아갈 수있다.
		 * 그리고 실행 대기 상태에 있는 다른 스레드가 선택되어 실행 상태가된다. 이렇게 번갈아가는것이다.
		 * 더이상 실행할 코드가 없으면 종료 상태로 돌아간다.
		 * 
		 */
		
		//yield() 다른스레드에게 실행 양보
		
		/*
		 * 스레드가 처리하는 작업은 반복적인 실행을 위해 포문이나 와일문을 포함하는 경우가 많다 가끔 이 반복문
		 * 들이 무의미한 반복을 하는 경우가 있다. 그래서 우선순위가 높은 스레드에게 양보를 할때 쓰인다.
		 */
		
		//join() 다른 스레드의 종료를 기다림
		
		/*
		 * 다른 스레드가 종료될 때까지 기다렸다가 실행해야하는 경우가 발생할 수 있다. 이때사용하는데, 이 스레드
		 * 가 종료할 때까지 메인스레드를 일시 정직시킨다.
		 */
		
		//wait() notify() notifyall() 스레드 간 협업
		
		/*
		 * 두개의 스레드를 교대로 번걸아가며 실행해야 할 경우가 있다. 자신의 작업이 끝나면 상대방 스레드를 일시
		 * 정지 상태에서 풀어주고, 자신은 일시 정지 상태로 만드는 것이다. 이 방법의 핵심은 공유 객체에 있다.
		 * 한 스레드가 작업을 완료하면 notify() 메소드를 호출해서 일시 정지 상태에 있는 다른 스레드를
		 * 실행대기 상태로 만들고 자신은 두 번 작업을 하지 않도록 wait()메소드를 호출하여 일시 정지 상태로 만든다
		 *
		 * 주의할 점은 이 메소드들은 동기화 메소드 또는 동기화 블록 내에서만 사용할 수 있다. 
		 */
		
		//데몬 스레드
		
		/*
		 *데몬 스레드는 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드이다.
		 *주 스레드가 종료되면 데몬 스레드는 강제적으로 자동 종료된다.
		 *데몬 스레드의 적용 예는 워드프로세서의 자동 저장 미디어플레이어의 동영상 및 음악 재생 가비지 컬렉터
		 *start() 하기 전에 setDemon(true) 를 해야 한다.
		 */
		
		//스레드 그룹
		
		/*
		 * 스레드 구릅은 관련된 스레드를 묶어서 관리할 목적으로 이용된다.
		 */
		
		//스레드 그룹 이름 얻기
		
		/*
		 * ThreadGroup group=Thread.currentThread().getThreadGroup();
		 * String groupName=group.getName();
		 */
		
		//스레드 그룹 생성
		
		/*
		 * ThreadGroup tg=new ThreadGroup(String name)
		 * ThreadGroup tg=new ThreadGroup(ThreadGroup parent,String name)
		 */
		
		//스레드 풀
		
		/*
		 * 병렬 작업 처리가 많아지면 스레드 개수가 증가되고 그에 따른 스레드 생성과 스케줄링으로 인해
		 * CPU가 바빠져 메모리 사용량이 늘어난다. 따라서 애플리케이션의 성능이 저하된다.
		 * 이것을 보안하기위해 스레드풀을 사용해야한다. 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해놓고
		 * 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리한다. 작업 처리가 끝난 스레드는 다시 작업 큐에서
		 * 새로운 작업을 가져와 처리한다. 
		 */
		
		//블로킹 방식의 작업 완료 통보
		
		/*
		 * ExecutorService의 submit() 메소드는 매개값으로 준 Runnable 또는 Callable 작업을
		 * 스레드 풀의 작업 큐에 저장하고 즉시 Future 객체를 리턴한다.
		 * Future 객체는 작업 결과가 아니라 작업이 완료될 때까지 기다렸다가(블로킹 되었다가) 최종 결과를
		 * 얻는데 사용된다. future.get()
		 */
		
		//작업 처리 결과를 외부 객체에 저장
		
		/*
		 * 상황에 따라서 스레드가 작업한 결과를 외부 객체에 저장해야 할 경우도 있다. 예를 들어 스레드가
		 * 작업 처리를 완료하고 외부 Result 객체에 작업 결과를 저장하면 애플리케이션이 Result 객체를
		 * 사용해서 어떤 작업을 진행할 수 있을 것이다.
		 * 작업 객체는 Runnable 구현 클래스로 생성한다
		 */
	}

}
