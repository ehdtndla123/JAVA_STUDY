package chapter15;

public class chapter15 {
	//ArrayList
	
	/*
	 * List의 인퍼테이스의 구현 클래스로 일반 배열과 인덱스로 객체를 관리한다는 점에서는 유사하지만, 큰 차이점을
	 * 가지고 있다. 저장용량을 초과하면 저장 용량이 자동적으로 늘어난다.
	 * 인덱스 검색이나 맨 마지막에 객체를 추가하는 경우에 좋은 성능을 발휘한다.
	 * 객체 삽입 삭제가 일어나는 경우엔 비효율적이다.
	 * 
	 */
	
	//Vector
	
	/*
	 * ArrayList와 다른점으로 Vector은 동기화된(synchronized) 메소드로 구성되어있기때문에 멀티 스레드가
	 * 동시에 이 메소드들을 실행할 수 없고 하나의스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.
	 */
	
	//LinkedList
	
	/*
	 * ArrayList는 내부 배열에 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼
	 * 관리한다. 객체 삽입 삭제에서 좋은 성능을 발휘한다.
	 */
	
	//Set 컬렉션
	
	/*
	 * List컬렉션은 저장 순서를 유지하지만 Set 컬렉션은 저장 순서가 유지되지 않는다.
	 * 객체 중복 저장 불가능하고 하나의 null만 저장할 수 있다. 집합에 비유될 수 있다.
	 * 
	 */
	
	//HashSet
	
	/*
	 * 중복이 발생할 일 없고 순서도 필요가 없다면 Set List 보다 HashSet이 실행속도 가 가장 빠르
	 * 
	 */
	
	//Map 컬렉션
	
	/*
	 * key와 value로 구성된 Entry 객체를 저장하는 구조를 가지고 있다.
	 * 키와 값은 모두 객체이며 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다.
	 */
	
	//HashMap
	
	/*
	 * 많은 양의 데이터를 가져와야한다면 keySet 보다 entrySet	의 성능이 훨 좋다.
	 */
	
	//Hashtable
	
	/*
	 * HashMap과의 차이점은 Hashtable은 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드
	 * 를 실행할 수없고 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.
	 */
	
	//Properties
	
	/*
	 * HashTable의 하위 클래스이기 때문에 모든 특징을 그대로 가지고 있다. 차이점으로
	 * 키와 값을 다양한 타입으로 지정이 가능한데 비해 properties는 키와 값을 String으로 제한한 컬렉션이다
	 * 애플리케이션의 옵션 정보 데이터베이스의 연결 정보 그리고 국제화 정보가 저장된 프로퍼티 파일을 읽을 때
	 * 주로 사용한다
	 * 
	 */
	
	//이진 트리 구조
	
	/*
	 * 여러개의 노드가 트리 형태로 연결된 구조로, 루트 노드라고 불리는 하나의 노드에서 부터 시작해서 각 노드에 최대
	 * 2개의 노드를 연결할 수 있는 구조를 가지고 있다.
	 */
	
	//TreeSet
	
	/*
	 * TreeSet은 이진트리를 기반으로한 Set컬렉션 
	 */
	
	//TreeMap
	
	/*
	 * TreeMap은 이진트리를 기반으로 한 Map컬렉션 TreeSet과의 차이점은 키와 값이 저장된 Map.Entry를 저장한다는 점
	 * 
	 */
	
}
